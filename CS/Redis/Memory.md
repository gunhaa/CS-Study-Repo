# Redis의 메모리 관리

## Redis의 메모리 관리에서 문제가 생기는 경우
- Redis는 최적화를 위해 내부적으로 jemalloc을 사용한다
- jemalloc은 글로벌 락을 사용하지 않기 때문에 성능성 이점이 있지만, 메모리 풀을 활용하기 때문에 max memory문제가 발생 가능해서 실 사용시 주의해야 한다
    - 실제 사용하는 메모리보다 더 많은 양의 메모리를 할당 받는다
    - jemalloc의 가장 큰 특징은 cache를 위해 free한 메모리에 대해서도 참조를 들고 있어 이중참조가 생겨 문제가 생길 수 있다
        - 데이터의 유실도 문제지만, 가장 큰 문제는 max memory이상을 실제로 사용해 메모리 누수를 넘어서 서비스가 중지 될 수 있다
    - jemalloc은 메모리 파편화를 줄이고, 빠른 재할당을 위해 풀방식으로 메모리를 운영한다.
        - 이 과정에서 free된 메모리조차 jemalloc 내부적으로는 유지된다. 즉, 커널에 반환되지 않고, jemalloc 내부 캐시에 남는다.
        - Redis 입장에선 이미 free된 메모리인데도 jemalloc이 잡고 있기 때문에, INFO MEMORY 상에서 사용량은 낮게 보이지만, 시스템 전체 메모리 기준에서는 여전히 사용 중으로 판단된다.
        - 즉, Redis의 상태는 낮은 메모리 사용(1G)이지만 실제는 더 많은 메모리를 사용중(캐시유지 중, 3G)이다
            - 이 경우 outofmemory의 위험이 크다
## 위험 시나리오
Redis는 jemalloc을 통해 1GB 예비 메모리를 확보
- 캐시 재사용 통해 잘 운영 중
- 새로운 요청 들어옴: arena2에서 512MB 필요
- 해당 arena엔 여유 없음(메모리 파편화 등의 이슈로인해) → OS에 mmap 요청
- OS는 이미 전체 메모리 거의 소진 상태
- mmap 실패 → Redis 프로세스 죽거나 OOM 발생