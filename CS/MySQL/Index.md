# 인덱스

- DBMS에서 인덱스란, 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기(SELECT) 속도를 높이는 기능이다
- 테이블에 인덱스를 추가하는 것은 데이터의 저장속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다
- Primary키는 레코드를 대표하는 컬럼의 값으로, 이미 만들어진 인덱스를 의미한다
  - Primary key를 제외한 나머지 모든 인덱스는 세컨더리 엔덱스로 분류한다
  - 인덱스는 B-Tree, R-Tree를 사용한다(MySQL)
    - Memory기반 DB에서는 Hash 인덱스를 사용 하기도하며, Fractal-Tree, Merge-Tree 인덱스를 사용하는 인덱스도 있다.

## B-Tree 인덱스

- 인덱스의 핵심은 값이 `정렬`되어 있다는 것이다
- 'Binary Tree'가 아닌 'Balanced Tree'의 약자다
- MySQL의 인덱스의 자료구조는 B+ 트리를 사용한다
  - B+의 트리의 주요 특징으로는 브랜치 노드는 값을 가르키는 포인터의 값만 저장되며, 리프노드에 직접적인 값이 저장된다
  - 브랜치노드는 범위 연산(부등호 연산)에서 빠르게 데이터를 찾을 수 있도록 가이드 역할을 한다
  - 리프 노드는 실제 row 데이터를 포함하며, 리프 노드들끼리는 연결 리스트로 연결되어 있다
- B-Tree의 경우, 찾는 연산에는 강하지만 insert와 delete연산은 해야할 일이 많아 소모 값이 크다
  - 즉, 인덱스가 많아질수록 연산시간이 n배가 드는 것이 아니라 (n+@)배의 시간이 든다
  - B-Tree에 insert, delete 연산시 트리의 균형과 부등호를 맞추기 위해 알맞은 곳에 추가/삭제 하는 과정에서 percolateUp, Down, 브랜치 노드의 추가,삭제와 대규모 이동이 일어나서 인덱스가 있는 곳에 삽입될 경우, 단순한 테이블 삽입이 아닌 그보다 더 많은 시간이 든다
- depth는 5이상까지는 가지 않는다
- 인덱스를 통한 접근이 항상 빠른 것은 아니다.

  - 인덱스 탐색 후 실제 row를 다시 조회하는 과정에서 I/O가 중복될 수 있다
    - B+Tree 중간 노드 탐색 (1~3단계 I/O)
    - 리프 노드에 도달
    - 추가로 실제 레코드를 읽기 위해 테이블 영역까지 한번 더 I/O
  - DB 옵티마이저는 이러한 오버헤드를 고려해, 경우에 따라 인덱스보다 테이블 전체 스캔을 더 저렴하게 판단할 수 있다
  - 일반 DBMS 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 비용이 더 든다고 예측한다

    - 그래서 옵티마이저가 판단하기에 전체 테이블의 20-25%(x4~x5한다면 100을 초과)를 넘게 읽어야 한다는 판단을 하게되면 전체 테이블을 모두 읽어서 필터링으로 처리한다(풀 데이터 스캔)

    ```sql
    -- users 테이블에 10만 건이 있고,
    -- 그 중 30%가 age = 30 조건을 만족한다고 하자

    SELECT * FROM users WHERE age = 30;

    -- 옵티마이저는 statistics를 기반으로
    -- age=30 조건이 전체의 30%를 반환한다고 판단하면

    -- 풀 테이블 스캔 선택 (인덱스 무시)
    ```

### 통계정보(Statistics)

- statistics는 테이블의 데이터의 분포나 특성을 저장한 동적인 정보다
- 옵티마이저는 이걸 기반으로 어떤 실행 계획이 효율적인지 판단한다
- 포함하는 정보 예시
  - 테이블의 전체 row 수
  - 인덱스별 key의 카디널리티(고유값 수)
  - 특정 컬럼 값의 분포 (히스토그램)
  - NULL의 비율
  - 컬럼 간 상관관계 (최신 DBMS에서)

### MySQL 인덱스 스캔 방식

#### 1. Index Range Scan (인덱스 레인지 스캔)

- 정의: 인덱스의 일부 범위만 탐색하여 필요한 레코드만 가져오는 방식
- 사용 조건
  - WHERE 절에 `=`, `<`, `>`, `BETWEEN`, `LIKE 'abc%'` 같은 비교 연산자 사용
  - 해당 컬럼에 인덱스가 걸려 있어야 함
- 예시
  ```sql
  SELECT * FROM users WHERE age BETWEEN 20 AND 30;
  ```

#### 2. Index Full Scan (인덱스 풀 스캔)

- 정의: 인덱스 전체를 처음부터 끝까지 순차적으로 탐색
- 사용 조건
  - WHERE 조건이 없거나, 인덱스만으로 SELECT가 처리 가능한 경우
  - 테이블 전체 스캔보다 I/O 비용이 더 적다고 옵티마이저가 판단할 때
    - 인덱스만으로 원하는 데이터를 모두 가져올 수 있어, 별도로 테이블에 접근할 필요가 없을때
- 예시
  ```sql
  SELECT name FROM users ORDER BY name;
  ```

#### 3. Loose Index Scan (루스 인덱스 스캔)

- 정의: GROUP BY 또는 DISTINCT 쿼리에서 중복을 건너뛰며 인덱스를 건너뛰어 탐색하는 방식
- 사용 조건
  - DISTINCT, GROUP BY, ORDER BY 조건이 인덱스 컬럼 순서와 일치
  - Covering Index 조건 충족 (인덱스만으로 SELECT가 가능)
- 예시
  ```sql
  SELECT DISTINCT user_id FROM posts ORDER BY user_id;
  ```
