# Java Memory Model

- JMM(Java memory model)은 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정한다
- 멀티스레드 프로그래밍에서 스레드 간의 상호작용을 정의한다
- 핵심은 happens-before 관계에 대한 정의이다
  - 여러 스레드들의 작업 순서를 보장하는 것

## happens-before

- 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다
  - A 작업이 B작업보다 happens-before 관계에 있다면, A 작업에서의 모든 메모리 변경 사항은 B 작업에서 볼 수 있다. 즉 A 작업에서 변경된 내용은 B 작업이 시작 되기 전에 모두 메모리에 반영된다
- happens-before 관계는 이름 그대로, 한 동작이 다른 동작보다 먼저 발생함을 보장한다(volatile을 쓰면 happens-before 관계가 성립하게 된다)
- happens-before 관계가 성립한다면, 한 스레드의 작업을 다른 스레드에서 볼 수 있게 된다
  - 즉, 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태가 보장되는 것이다
  - 이 규칙을 따르면 멀티스레드 프로그램을 작성할 때 예상치 못한 동작을 피할 수 있다

### happens-before 관계가 발생하는 경우

- 프로그램 순서 규칙
  - 모든 명령문은 순서대로 실행된다
  - 코드가 위에서부터 아래로 실행 된다는 뜻
- volatile
  - volatile에 대한 쓰기 작업은 해당 쓰레드를 모든 스레드에 보이도록 한다
  - 변수를 읽는 작업보다 happens-before 관계를 형성한다
- 스레드 규칙
  - start() 호출 이후 스레드 내 모든 작업은 happens-before 관계가 성립한다
  - join() 호출 이전 thread의 모든 작업이 완료되어야 하며, join()이후 참조 가능하다
  - interrup() 호출 작업이, 인터럽트를 감지하는 시점의 작업보다 happens-before 관계가 성립한다
- 모니터 락 규칙
  - 락을 얻는 모든 스레드는 해당 블록 내의 모든 작업을 볼 수 있다

## Recap

- 즉, volatile 또는 synchronized, ReentrantLock 을 사용하면 메모리 가시성 문제가 발생하지 않는다