# 생산자와 소비자 문제

- 생산자 소비자 문제는 멀티스레드 프로그래밍에서 자주 등장하는 동시성 문제 중 하나로, 여러 스레드가 동시에 데이터를 생상하고 소비하는 상황을 다룬다
- 멀티 스레드의 핵심이며, 올바른 해결 방안도 알아두어야한다
  - ex) 프린터 예제

## 생산자

- 데이터를 생성하는 역할을 한다
- 파일에서 데이터를 읽어오거나, 네트워크에서 데이터를 받아오는 스레드가 생산자 역할을 할 수 있다
- 버퍼: 생산자가 생성한 데이터를 일시적으로 저장하는 공간
  - 버퍼는 한정된 크기를 가지며, 생산자와 소비자가 이 버퍼를 통해 데이터를 주고 받는다

## 소비자

- 생성된 데이터를 사용하는 역할을 한다
- 데이터를 처리하거나 저장하는 스레드가 소비자 역할을 할 수 있다

## 문제 상황

1. 생산자가 너무 빠를때: 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 계속 생성한다. 버퍼가 가득 찬 경우 생산자는 버퍼에 빈 공간이 생길 때 까지 기다려야 한다
2. 소비자가 너무 빠를때: 버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다. 버퍼가 비어있을 때 소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다

- 이 문제는 생산자 소비자 문제(producer-consumer problem), 혹은 한정된 버퍼 문제(bounded-buffer problem)라고 불린다

### 해결 방법1

> 대기할때 lock을 반납하여, 생산자 혹은 소비자가 사용할 수 있게 한다

- Object 클래스의 wait(), notify() 사용
- Object.wait()
  - 현재 스레드가 가진 락을 반납하고 대기(WAITING)로 변경
  - 이 메서드는 현재 스레드가 synchronized 블록이나 메서드에서 락을 소유하고 있을때만 호출 가능하다
  - 호출한 스레드는 락을 반납하고, 다른 스레드가 락을 획득할 수 있도록 한다
  - 이렇게 대기 상태로 전환된 스레드는 다른 스레드가 notify(), notifyAll()을 호출하기 전 까지 대기한다
- Object.notify()
  - 대기 중인 스레드 중 하나를 깨운다
  - 이 메서드는 synchronized 블록이나 메서드에서 호출해야 한다
  - 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다
  - 대기중인 스레드가 여러개라면, 그 중 하나만 깨워지게 된다
- Object.notifyAll()
  - 대기중인 모든 스레드를 깨운다
  - 이 메서드 역시 synchronized 블록이나 메서드에서 호출되어야 한다
  - 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다
  - 모든 스레드를 깨워야할때 유용하다
- 해당 Object의 메서드를 사용해 멀티스레드의 문제를 (일부)해결할 수 있다
  - Java가 멀티스레드 언어로 설계되었기 때문에 Object에 해당 기능이 존재하는 것이다
  - Java의 모든 객체는 락/스레드 대기집합(waitset, JVM이 락을 사용시 동적으로 만들어내고 관리함, 이 곳에 있는 스레드들에게 notify()를 통해 알린다)을 가지고 있다
  - 이 방법에는 문제가있다, 원하는 종류의 스레드(producer, comsumer)를 선택해서 깨우지 못한다(CPU 낭비)
    - wait(), notify()는 스레드 집합이 한개이기 때문에 이런 비효율이 발생할 수 있다
    - starvation(기아) 발생 가능성이있다(consumer 다수, producer 소수 혹은 반대인 경우)
      - notifyAll()로 기아를 어느정도 막을 수 있지만, 비효율은 막지 못한다
    - 깨어난 스레드가 일을 하지 않고 다시 잠들면 의미 없는 context switching이 발생한다
      - notify() → 조건 불만족 스레드 → 다시 wait()
      - 이런 과정이 반복되면, 진짜 일할 수 있는 스레드는 대기 중인데,
      - 다른 스레드만 깨어나고 돌아가기를 반복하게 되어 전체적으로 비효율적인 스케줄링이 된다

### 해결방법2

```java
    private final Lock lock = new ReentrantLock();

    // condition은 스레드가 대기하는 대기집합
    private final Condition producerCond = lock.newCondition();
    private final Condition consumerCond = lock.newCondition();
```

- 대기 집합(lock.newCondition())을 만들어, 대기 그룹을 분리한 후 원하는 그룹에 신호를 줘서 스레드를 호출한다
- CPU낭비 없는 효율적인 프로그래밍이 가능하다
- 해당 구현은 실무에서 사용할 수 있는 수준의 구현이다

### 해결방법3

- java에서 제공하는 BlockingQueue(인터페이스) 자료구조를 이용하여 해결한다
  - 큐가 가득 차면 데이터 추가 작업(put())을 시도하는 스레드는 공간이 생길 때 까지 차단된다
  - 큐가 비어 있으면 획득 작업(take())을 시도하는 스레드는 큐에 데이터가 들어올 때까지 차단된다
  - 대표적인 구현체는 두가지가 있다
    - ArrayBlockingQueue: 배열 기반으로 구현, 버퍼의 크기가 고정
    - LinkedBlockingQueue: 링크 기반으로 구현, 버퍼의 크기를 고정/무한으로 모두 사용 가능

#### BlockingQueue

- 구현해 본 BoundedQueueV5와 내부 구현이 거의 똑같다

| Operation (기능) | Throws Exception (예외 발생) | Special Value (즉시 반환) | Blocks (무한 대기) | Times Out (시간 대기) |
|------------------|-------------------------------|-----------------------------|----------------------|------------------------|
| **Insert (추가)**   | `add(e)`<br>큐가 가득 차면 `IllegalStateException` | `offer(e)`<br>가득 차면 `false` 반환 | `put(e)`<br>큐가 가득 차면 대기 | `offer(e, time, unit)`<br>시간 내에 실패하면 `false` 반환 |
| **Remove (제거)**   | `remove()`<br>비어 있으면 `NoSuchElementException` | `poll()`<br>비어 있으면 `null` 반환 | `take()`<br>큐가 비어 있으면 대기 | `poll(time, unit)`<br>시간 내에 실패하면 `null` 반환 |
| **Examine (관찰)**  | `element()`<br>비어 있으면 `NoSuchElementException` | `peek()`<br>비어 있으면 `null` 반환 | 해당 없음 | 해당 없음 |
