# 원자적 연산

- 컴퓨터 과학에서 사용하는 원자적 연산의 의미하는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미한다
- 원자적 연산은 중단되지 않고 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있다
  - 즉, 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산

```java
volatile int i = 0;
// 위 연산은 쪼갤 수 없는 원자적 연산이다
// 오른쪽에있는 1의 값을 왼쪽에 있는 i의 변수에 대입

int i = i + 1;
// 하지만 위 코드는 원자적 연산이 아니다
// 이 연산은 3단계로 수행된다
// 1. 오른쪽에 있는 i의 값을 읽는다, i = 10이라고 가정한다
// 2. 읽은 10에 1을 더해서 11로 만든다
// 3. 더한 11을 왼쪽의 i 변수에 대입한다
```

- 원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다. 하지만 원자적 연산이 아닌 경우에는 synchronized 블럭이나 Lock을 이용해 안전한 임계영역을 만들어 내야 한다
- 동시에 실행하는 경우 아래처럼 문제가 발생할 확률이 생긴다

```plaintext
처음에 i = 0이라고 가정
스레드1: i = i + 1 연산 수행
스레드2: i = i + 1 연산 수행
스레드1: i의 값을 읽는다. i는 0이다.
스레드2: i의 값을 읽는다. i는 0이다.
스레드1: 읽은 0에 1을 더해서 1을 만든다.
스레드2: 읽은 0에 1을 더해서 1을 만든다.
스레드1: 더한 1을 왼쪽의 i변수에 대입한다.
스레드2: 더한 1을 왼쪽의 i변수에 대입한다.
결과: i의 값은 1이다
```

## java의 원자적 연산 수행방법

```java
        // 일반 integer 사용(문제 발생)
        test(new BasicInteger());
        // volatile 필드 사용(문제 발생)
        test(new VolatileInteger());
        // synchronized 사용
        test(new SyncInteger());
        // AtomicIntger 사용
        test(new MyAtomicInteger());
```

- 성능 테스트 결과

```plaintext
BasicInteger: ms=16
VolatileInteger: ms=593
SyncInteger: ms=1904
MyAtomicInteger: ms=703
```

- AtomicInteger는 락을 사용하지않는 CAS 구현을 사용해 성능이 눈에 띌 정도로 좋다