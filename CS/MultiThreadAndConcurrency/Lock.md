# 실무 관점의 Lock

- 실무 관점에서 보면 대부분의 어플리케이션은 공유 자원을 사용할 때, 충돌 가능성보다 충돌하지 않을 가능성이 훨씬 더 높다
- 예를들어 특정 피크시간에 주문이 100만건이 들어오는 서비스에서(한국 탑급 서비스임) 주문 수를 실시간으로 증가하면서 카운트한다고 가정하면
  - 1000000/60분 = 1분에 16,666건 = 1초에 277건
  - CPU가 1초에 얼마나 많은 연산을 처리하는지 생각해보면, 백만 건 중 충돌이 나는 경우는 아주 넉넉하게 해도 몇 십건 이하이다
  - 따라서 실무에서 주문 수 증가와 같은 단순한 연산의 경우, 락을 걸고 시작하는 것 보다는 CAS처럼 낙관적인 방식이 더 나은 성능을 보인다
  - 여기서 가장 중요한 핵심은 주문 수 증가와 같은 단순한 연산이라는 점이다
  - 이런 경우 `AtomicInteger`와 같은 CAS 연산을 사용하는 방식이 효과적이며, 이런 연산은 나노 초 단위로 발생하는 연산이다
  - 반면에 DB를 대기하거나, 다른 서버의 요청을 기다리는 것처럼 수 밀리초 이상의 시간이 걸리는 작업이라면 CAS를 사용하는 것보다 동기화 락을 사용하거나 스레드가 대기하는 방식이 더 효율적이다