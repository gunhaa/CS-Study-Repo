# synchronized

- 모든 객체는 내부에 자신만의 락을 가지고 있다
  - 모니터 락 이라고도 부른다
  - 객체 내부에 있고, 확인은 어렵다
  - 인스턴스가 락을 가지고 있다(메서드 마다 락이 있는 것이 아니다)
- 스레드가 synchronized 키워드에 진입하기 위해서는 반드시 해당 인스턴스의 락이 있어야 한다
  - 스레드가 synchronized 키워드 메서드를 실행시키면, 해당 메서드의 인스턴스에 있는 락을 획득한다
  - synchronized 메서드가 여러 개 있는 같은 인스턴스의 경우, 하나의 락을 공유하므로 동시에 접근할 수 없다
  - 락을 획득한 후, 메서드 사용이 끝나면 바로 락을 반납한다
- 락이 없는 상태의 synchronized 메서드에 접근하려는 스레드는 상태를 RUNNABLE에서 BLOCKED상태로 변하며, 락을 획득할 때 까지 무한정 대기한다
  - BLOCKED 상태가 되면 락을 다시 획득하기 전까지는 계속 대기하고, CPU 실행 스케줄링에 들어가지 않는다
- 주의: 락을 획득하는 순서는 보장되지 않는다
  - 락의 획득 순서는 자바 표준에 정의되어 있지 않다
  - 하지만 일반적(확률적)으로 오래 기다린 경우가 락을 획득할 확률이 높다
- volatile을 사용하지 않더라도, synchronized를 사용한다면 메모리 가시성 문제가 해결된다

## 코드블록 synchronized

- 성능 문제가 발생하기 때문에, 동시에 실행할 수 없는 코드 구간은 반드시 필요한 곳으로 한정하여 설정해야 한다
  - 병목현상을 최대한 줄이기 위해, 최대한 짧게 만들어야 한다

## Recap

- synchronized(동기화)를 사용하면 다음 문제를 해결 할수있다
  - 경합 조건(race condition): 두개 이상의 스레드가 경쟁적으로 동일한 자원을 수정할때 발생
  - 데이터 일관성: 여러 스레드가 동시에 읽고 쓰는 데이터의 일관성을 유지
