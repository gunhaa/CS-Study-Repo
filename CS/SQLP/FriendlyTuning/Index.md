# 인덱스 기본

## 인덱스 구조 및 탐색

### DBMS가 데이터를 찾는 두가지 방법

> 수십년에 걸쳐 DBMS가 발전해왔는데 이 두 가지 방법에서 크게 벗어나지 못했다

- 테이블 전체를 스캔한다
- 인덱스를 이용한다

### 인덱스 구조

- 인덱스는 B\* 트리(B+ 트리의 성능을 개선한 구조)를 사용한다

#### B+ 트리의 특징

- gt, lt의 검색을 효율저긍로 위한 트리 구조이다
- branch에 leaf노드에 대한 정보는 없고, 검색을 위한 key와 leaf에 대한 포인터 밖에 없다
- gt, lt연산에 특화되어 있고 이 정보를 이용해 leaf노드의 정보를 가져온다
- b트리의 b는 balanced tree이기 때문에 어떤 leaf노드든 root와 높이가 같다
- leaf노드는 양방향 연결리스트로 구성되어 접근이 빠르다

### 인덱스 탐색

1. 수직적 탐색

- 인덱스 스캔의 시작지점을 찾는다
- branch 의 key를 이용해 탐색을 시작할 지점을 찾는다

2. 수평적 탐색

- branch의 key를 이용해 탐색할 지점부터 시작해, double linked list 구조를 이용해 수평적 탐색을 한다
  - 이를 통해 ROWID(레코드의 포인터)를 얻어, Table에 접근한다

#### 결합 인덱스 탐색

- 결합 인덱스는 속성의 순서가 중요하다
- 먼저 생성된 속성부터 접근해 탐색을 하며, 순서에 따라 성능에서 큰 차이가 난다
  - 일반적으로 선택도가 높은 컬럼(서로 다른 값이 많은 컬럼, 즉 카디널리티가 높은 컬럼)을 앞에 두는 것이 성능에 유리하다.
    - 카디널리티: 서로 다른 값의 갯수(예: 성별 컬럼의 카디널리티는 2 (남, 여))
    - 선택도 = 조건에 해당하는 레코드 수 / 전체 레코드 수
      - 선택도가 높다 = 적은 수의 레코드만 나온다 → 잘 필터링된다 → 인덱스 효율이 좋다
      - 선택도 = 1 / 카디널리티(카디널리티가 높아질수록, 선택도(수식)은 낮아진다)
      - "카디널리티 ↑ ⇒ 선택도(효율) ↑"
      - "카디널리티 ↑ ⇒ 선택도(수식) ↓"
      - 선택도의 효율이라는 관점에서, 선택도의 효율 = 카디널리티라고 생각하면 될듯함
